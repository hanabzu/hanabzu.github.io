---
layout: post

title: Effective C++ 정리 2. - 초기화

subtitle: 항목 4

author: hanabzu

categories: [Effective C++]

tags: ECpp Cpp

---

## 1. 객체 초기화

C++에서 객체의 값은 자동으로 초기화되는 경우도 있지만, 그렇지 않은 경우도 있다.  
초기화 규칙은 명확히 준비되어 있으나 다소 복잡하다.  
예를 들어 C++의 C 부분만 활용하며 초기화에 런타임 비용이 소모되는 상황이라면 값이 초기화된다는 보장이 없다.  
그러나 C가 아닌 부분을 사용하면 사정이 달라지기도 한다.  
배열의 경우는 초기화가 보장되지 않지만 STL의 `vector`는 보장되는 이유가 이런 법칙 때문이다.  
가장 좋은 방법은 **모든 객체를 사용하기 전에 항상 초기화하는 것**이다.  
기본제공 타입으로 만들어진 비멤버 객체는 아래와 같이 손수 초기화한다.

```cpp
int x = 0;

const char * text = "A C-style string";

double d;
std::cin >> d;
```

---

## 2. 생성자

생성자에서는 **객체의 모든 것을 초기화**한다.  
주의할 점으로, **대입(assignment)과 초기화(initialization)를 헷갈리지 않는다.**  
C++규칙에 의하면 어떤 객체든 그 객체의 데이터 멤버는 생성자의 본문이 실행되기 **전에** 초기화되어야 한다고 명기되어 있다.  
다음과 같이 대입문 대신 멤버 초기화 리스트를 사용하면 기본 생성자 호출 후 대입되는 대신 바로 초기화할 수 있다.

```cpp
ABEntry::ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones)
: theName(name),
  theAddress(address), 
  thePhones(phones), 
  numTimesConsulted(0)
{} // 생성자 본문은 비어있다.
```

매개변수 없는 생성자와 같은 경우에도, 다음과 같이 멤버 초기화 리스트를 사용하는 습관을 들이는 것이 좋다.

```cpp
ABEntry::ABEntry()
: theName(), 
  theAddress(), 
  thePhones(), // 각각 멤버 객체의 기본 생성자를 호출한다.
  numTimesConsulted(0)
{}
```

상수와 참조자는 대입 자체가 불가능하기 때문에, 이러한 데이터 멤버의 경우 반드시 초기화되어야 한다.  

현장에서 쓰이는 클래스들 대부분이 여러 생성자를 가지고 있고, 각 생성자마다 멤버 초기화 리스트가 붙어있다.  
이 경우 대입으로도 초기화가 가능한 데이터 멤버들을 별도의 함수로 관리하는 것도 나쁘지 않다.  
대개 `private 멤버` 함수 하나로 몰아놓고 모든 생성자에서 이 함수를 호출하게 하는 방법이다.  

---

## 3. 초기화 순서

어떤 컴파일러를 막론하고 객체를 구성하는 데이터의 초기화 순서는 항상 같다.  

1) 기본 클래스는 파생 클래스보다 먼저 초기화  
2) 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화

### 비지역 정적 객체

비지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다.  

**정적 객체(static object)** 는 전역 객체, 네임스페이스 유효범위에서 정의된 객체, 클래스 안에서 `static`으로 선언된 객체, 함수 안에서 `static`으로 선언된 객체, 그리고 파일 유효 범위에서 `static`으로 정의된 객체, 이렇게 다섯 종류가 있다.  
이들 중 함수 안에 있는 정적 객체는 **지역 정적 객체(local static object)** 라고 하며, 나머지는 **비지역 정적 객체(non-local static object)** 이라고 한다.  
이 정적 객체는 프로그램이 끝날 때 자동으로 소멸된다. 즉 `main()` 함수의 실행이 끝날 때 자동으로 정적 객체의 소멸자가 호출된다.  

**번역 단위(translation unit)** 는 컴파일을 통해 하나의 목적 파일을 만드는 바탕이 되는 소스 코드를 말한다.  
기본적으로는 소스 파일 하나가 되며, 그 파일이 `#include`하는 파일들까지 합쳐서 하나의 번역 단위가 된다.  

문제가 되는 상황은 별도로 컴파일된 두 개 이상의 소스 파일이 있는 경우, 어느 한 번역 단위에 있는 비정적 객체의 초기화가 진행되면서 다른 쪽 번역 단위에 있는 비지역 정적 객체가 사용될 때인데, 이 객체가 초기화되어 있지 않을 수도 있다는 것이다.  
이유는 **별개의 번역 단위에서 정의된 비지역 정적 객체들의 초기화 순서는 '정해져 있지 않다'** 라는 사실 때문이다.  

이러한 문제는 서로 다른 번역 단위의 우선 순위를 결정하기 매우 힘들기 때문에 생기는 문제로, 해결하기 위해서는 설계에 약간의 변화를 주어야 한다.  

비지역 정적 객체를 하나씩 맡는 함수를 준비하고 그 안에 각 객체를 넣은 후  함수 속에서 정적객체를 선언하고 함수에서는 이들에 대한 참조자를 반환하게 만든다. 사용자 쪽에서는 비지역 정적 객체를 직접 참조하지 않고 함수 호출로 대신한다.  
정리하자면 '비지역 정적 객체'가 '지역 정적 객체'로 바뀐 것이다. (디자인 패턴에서의 Singletone pattern의 전형적인 구현양식과 같다.)  

지역 정적 객체는 함수 호출 중에 그 객체의 정의에 최초로 닿았을 때 초기화되도록 만들어져 있다는 사실을 이용한 것으로, 반환되는 참조자는 반드시 초기회된 객체를 참조하도록 맞추어 주어야 한다.  추가로 이러한 함수를 호출할 일이 없다면 해당 객체의 생성/소멸 비용도 생기지 않도록 해야 한다.

```cpp
class FileSystem {...};

FileSystem& tfs() { // tfs 객체를 함수로 대신한다.
  static FileSystem fs;
  return fs;
}

class Directory {...};

Directory::Directory( params ){
  ...
  std::size_t disks = tfs().numDisks(); // 함수 호출
  ...
}

Directory& tempDir() { // tempDir 객체를 함수로 대신한다.
  static Directory td;
  return td;
}
```

다중 스레드 시스템에서는 정적 객체를 쓰기 때문에 동작에 장애가 생길 수 있다.  
(특히 다중 스레드 시스템에서 비상수 정적 객체는 많은 문제를 일으킨다.)  
이 때에는 다중 스레드로 프로그램이 돌입하기 전에 미리 참조자 반환 함수를 전부 호출하는 방법으로 초기화에 관계된 경쟁 상태(race condition)를 없앨 수 있다.

---

내용 출처 : 스콧 마이어스, 『이펙티브 C++』, 프로텍미디어(2015)
